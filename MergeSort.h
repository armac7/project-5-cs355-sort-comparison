#include <iostream>
#include "Sorter.h"

#ifndef MERGESORT_H
#define MERGESORT_H

template <typename type>
class MergeSort : public Sorter<type>
{
private:
    type *SortHelper(type *arr, int left, int right);
    type *Merge(type *left, type *right, int sizeL, int sizeR);

public:
    MergeSort(type *p, int s);
    virtual void Sort() override;
};

template <typename type>
MergeSort<type>::MergeSort(type *p, int s) : Sorter<type>(p, s){};

template <typename type>
void MergeSort<type>::Sort()
{
    type *arr = Sorter<type>::getAccess();
    arr = SortHelper(arr, 0, Sorter<type>::getSize() - 1);
    Sorter<type>::Reset(arr, Sorter<type>::getSize());
}

// This code was partially generated by ChatGBT.
// I got a good chunk of it, but could not get it to work properly without some minor changes that I could not, for the life of me, figure out.
// I figured out the sizeL, sizeR, leftArr, rightArr, as well as the filling parts (to merge the arrays) but could not figure out the left, mid,
// right parts no matter how hard I tried.
template <typename type>
type *MergeSort<type>::SortHelper(type *arr, int left, int right)
{
    if (left < right)
    {
        int mid = left + (right - left) / 2;
        SortHelper(arr, left, mid);
        SortHelper(arr, mid + 1, right);

        // creates the two different arrays from the parts sorted above
        int sizeL = mid - left + 1;
        int sizeR = right - mid;
        type *leftArr = new type[sizeL];
        type *rightArr = new type[sizeR];

        // fills the arrays with the contents of arr
        for (int i = 0; i < sizeL; i++)
            leftArr[i] = arr[left + i];
        for (int j = 0; j < sizeR; j++)
            rightArr[j] = arr[mid + 1 + j];

        // merges the arrays
        type *mergedArr = Merge(leftArr, rightArr, sizeL, sizeR);

        // moves from the merged array back to the arr.
        for (int k = 0; k < sizeL + sizeR; k++)
            arr[left + k] = mergedArr[k];

        delete[] leftArr;
        delete[] rightArr;
        delete[] mergedArr;

        return arr;
    }
}

// coded this entirely myself, may not be the most efficient way to do it, but it works.
template <typename type>
type *MergeSort<type>::Merge(type *left, type *right, int sizeL, int sizeR)
{
    // values necessary for merging.
    int indexL = 0;
    int indexR = 0;
    int merged = 0;
    type *merge = new type[sizeL + sizeR];

    while (indexL < sizeL || indexR < sizeR) // merge the two lists until the end of one is reached
    {
        if (indexL == sizeL || indexR == sizeR)
            break;

        if (left[indexL] < right[indexR]) // if left index is less than right index, put left in merged
        {
            merge[merged] = left[indexL];
            indexL++;
        }
        else // else if right index is less than left index, put right in merged
        {
            merge[merged] = right[indexR];
            indexR++;
        }
        merged++;
        Sorter<type>::incrementCounter(); // increment counter
    };

    while (indexL != sizeL) // if end of left is not reached, reach it.
    {
        merge[merged] = left[indexL];
        merged++;
        indexL++;
        Sorter<type>::incrementCounter();
    }
    while (indexR != sizeR) // if end of right is not reached, reach it.
    {
        merge[merged] = right[indexR];
        merged++;
        indexR++;
        Sorter<type>::incrementCounter();
    }

    return merge;
}

#endif